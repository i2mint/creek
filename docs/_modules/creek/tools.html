<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>creek.tools &mdash; creek 0.1.27 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> creek
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek.html">creek</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/base.html">creek.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/infinite_sequence.html">creek.infinite_sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/labeling.html">creek.labeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/multi_streams.html">creek.multi_streams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/scrap/async_utils.html">creek.scrap.async_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/scrap/creek_layers.html">creek.scrap.creek_layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/scrap/multi_streams.html">creek.scrap.multi_streams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/tests/infinite_sequence.html">creek.tests.infinite_sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/tests/labeling.html">creek.tests.labeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/tools.html">creek.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/creek/util.html">creek.util</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">creek</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>creek.tools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for creek.tools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tools to work with creek objects&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">from</span> <span class="nn">creek.util</span> <span class="kn">import</span> <span class="n">Pipe</span>

<span class="n">Index</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">DataItem</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;DataItem&#39;</span><span class="p">)</span>
<span class="c1"># TODO: Could have more args. How to specify this in typing?</span>
<span class="n">IndexUpdater</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Index</span><span class="p">,</span> <span class="n">DataItem</span><span class="p">],</span> <span class="n">Index</span><span class="p">]</span>
<span class="n">Indexer</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DataItem</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">DataItem</span><span class="p">]]</span>


<div class="viewcode-block" id="apply_and_fanout"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.apply_and_fanout">[docs]</a><span class="k">def</span> <span class="nf">apply_and_fanout</span><span class="p">(</span>
    <span class="n">seq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">],</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Apply function (that returns an Iterable) to an element of a sequence</span>
<span class="sd">    and fanout (broadcast) the resulting items, to produce an iterable of tuples each</span>
<span class="sd">    containing</span>
<span class="sd">    one of these items along with &#39;a copy&#39; of the other tuple elements</span>

<span class="sd">    &gt;&gt;&gt; list(apply_and_fanout([1, &#39;abc&#39;, 3], iter, 1))</span>
<span class="sd">    [(1, &#39;a&#39;, 3), (1, &#39;b&#39;, 3), (1, &#39;c&#39;, 3)]</span>
<span class="sd">    &gt;&gt;&gt; list(apply_and_fanout([&#39;bob&#39;, &#39;alice&#39;, 2], lambda x: x * [&#39;hi&#39;], 2))</span>
<span class="sd">    [(&#39;bob&#39;, &#39;alice&#39;, &#39;hi&#39;), (&#39;bob&#39;, &#39;alice&#39;, &#39;hi&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; list(apply_and_fanout([&quot;bob&quot;, &quot;alice&quot;, 2], lambda x: x.upper(), 1))</span>
<span class="sd">    [(&#39;bob&#39;, &#39;A&#39;, 2), (&#39;bob&#39;, &#39;L&#39;, 2), (&#39;bob&#39;, &#39;I&#39;, 2), (&#39;bob&#39;, &#39;C&#39;, 2), (&#39;bob&#39;, &#39;E&#39;, 2)]</span>

<span class="sd">    See Also:</span>
<span class="sd">        ``fanout_and_flatten`` and ``fanout_and_flatten_dicts``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>  <span class="c1"># TODO: Overhead: Should we impose seq to be tuple?</span>
    <span class="n">left_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">right_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">left_seq</span> <span class="o">+</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span> <span class="o">+</span> <span class="n">right_seq</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">func</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span></div>


<div class="viewcode-block" id="fanout_and_flatten"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.fanout_and_flatten">[docs]</a><span class="k">def</span> <span class="nf">fanout_and_flatten</span><span class="p">(</span><span class="n">iterable_of_seqs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">aggregator</span><span class="o">=</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply apply_and_fanout to an iterable of sequences.</span>

<span class="sd">    &gt;&gt;&gt; seq_iterable = [(&#39;abcdef&#39;, &#39;first&#39;), (&#39;ghij&#39;, &#39;second&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; func = lambda a: zip(*([iter(a)] * 2))  # func is a chunker</span>
<span class="sd">    &gt;&gt;&gt; assert list(fanout_and_flatten(seq_iterable, func, 0)) == [</span>
<span class="sd">    ...     ((&#39;a&#39;, &#39;b&#39;), &#39;first&#39;),</span>
<span class="sd">    ...     ((&#39;c&#39;, &#39;d&#39;), &#39;first&#39;),</span>
<span class="sd">    ...     ((&#39;e&#39;, &#39;f&#39;), &#39;first&#39;),</span>
<span class="sd">    ...     ((&#39;g&#39;, &#39;h&#39;), &#39;second&#39;),</span>
<span class="sd">    ...     ((&#39;i&#39;, &#39;j&#39;), &#39;second&#39;)</span>
<span class="sd">    ... ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">apply</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">apply_and_fanout</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">aggregator</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">apply</span><span class="p">,</span> <span class="n">iterable_of_seqs</span><span class="p">))</span></div>


<div class="viewcode-block" id="fanout_and_flatten_dicts"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.fanout_and_flatten_dicts">[docs]</a><span class="k">def</span> <span class="nf">fanout_and_flatten_dicts</span><span class="p">(</span>
    <span class="n">iterable_of_dicts</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">idx_field</span><span class="p">,</span> <span class="n">aggregator</span><span class="o">=</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply apply_and_fanout to an iterable of dicts.</span>

<span class="sd">    &gt;&gt;&gt; iterable_of_dicts = [</span>
<span class="sd">    ...     {&#39;wf&#39;: &#39;abcdef&#39;, &#39;tag&#39;: &#39;first&#39;}, {&#39;wf&#39;: &#39;ghij&#39;, &#39;tag&#39;: &#39;second&#39;}</span>
<span class="sd">    ... ]</span>
<span class="sd">    &gt;&gt;&gt; func = lambda a: zip(*([iter(a)] * 2))  # func is a chunker</span>
<span class="sd">    &gt;&gt;&gt; fields = [&#39;wf&#39;, &#39;tag&#39;]</span>
<span class="sd">    &gt;&gt;&gt; idx_field = &#39;wf&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert list(</span>
<span class="sd">    ...     fanout_and_flatten_dicts(iterable_of_dicts, func, fields, idx_field)) == [</span>
<span class="sd">    ...         {&#39;wf&#39;: (&#39;a&#39;, &#39;b&#39;), &#39;tag&#39;: &#39;first&#39;},</span>
<span class="sd">    ...         {&#39;wf&#39;: (&#39;c&#39;, &#39;d&#39;), &#39;tag&#39;: &#39;first&#39;},</span>
<span class="sd">    ...         {&#39;wf&#39;: (&#39;e&#39;, &#39;f&#39;), &#39;tag&#39;: &#39;first&#39;},</span>
<span class="sd">    ...         {&#39;wf&#39;: (&#39;g&#39;, &#39;h&#39;), &#39;tag&#39;: &#39;second&#39;},</span>
<span class="sd">    ...         {&#39;wf&#39;: (&#39;i&#39;, &#39;j&#39;), &#39;tag&#39;: &#39;second&#39;}</span>
<span class="sd">    ... ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">egress</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">fields</span><span class="p">),</span> <span class="nb">dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span>
        <span class="n">egress</span><span class="p">,</span>
        <span class="n">fanout_and_flatten</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">fields</span><span class="p">),</span> <span class="n">iterable_of_dicts</span><span class="p">),</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
            <span class="n">idx</span><span class="o">=</span><span class="n">fields</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx_field</span><span class="p">),</span>
            <span class="n">aggregator</span><span class="o">=</span><span class="n">aggregator</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="filter_and_index_stream"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.filter_and_index_stream">[docs]</a><span class="k">def</span> <span class="nf">filter_and_index_stream</span><span class="p">(</span>
    <span class="n">stream</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">data_item_filt</span><span class="p">,</span> <span class="n">timestamper</span><span class="p">:</span> <span class="n">Indexer</span> <span class="o">=</span> <span class="nb">enumerate</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Index a stream and filter it (based only on the data items).</span>

<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ... list(filter_and_index_stream(&#39;this  is   a   stream&#39;, data_item_filt=&#39; &#39;)) == [</span>
<span class="sd">    ... (0, &#39;t&#39;),</span>
<span class="sd">    ... (1, &#39;h&#39;),</span>
<span class="sd">    ... (2, &#39;i&#39;),</span>
<span class="sd">    ... (3, &#39;s&#39;),</span>
<span class="sd">    ... (6, &#39;i&#39;),</span>
<span class="sd">    ... (7, &#39;s&#39;),</span>
<span class="sd">    ... (11, &#39;a&#39;),</span>
<span class="sd">    ... (15, &#39;s&#39;),</span>
<span class="sd">    ... (16, &#39;t&#39;),</span>
<span class="sd">    ... (17, &#39;r&#39;),</span>
<span class="sd">    ... (18, &#39;e&#39;),</span>
<span class="sd">    ... (19, &#39;a&#39;),</span>
<span class="sd">    ... (20, &#39;m&#39;)</span>
<span class="sd">    ... ])</span>

<span class="sd">    &gt;&gt;&gt; list(filter_and_index_stream(</span>
<span class="sd">    ...     [1, 2, 3, 4, 5, 6, 7, 8],</span>
<span class="sd">    ...     data_item_filt=lambda x: x % 2))</span>
<span class="sd">    [(0, 1), (2, 3), (4, 5), (6, 7)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">data_item_filt</span><span class="p">):</span>
        <span class="n">sentinel</span> <span class="o">=</span> <span class="n">data_item_filt</span>
        <span class="n">data_item_filt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">sentinel</span>
    <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">data_item_filt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">timestamper</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span></div>


<span class="c1"># TODO: Refactor dynamic indexing set up so that</span>
<span class="c1">#  IndexUpdater = Callable[[DataItem, Index, ...], Index] (data and index inversed)</span>
<span class="c1">#  Rationale: One can (and usually would want to) have a default current_idx, which</span>
<span class="c1">#  can be used as the start index too.</span>
<span class="n">count_increments</span><span class="p">:</span> <span class="n">IndexUpdater</span>


<span class="k">def</span> <span class="nf">count_increments</span><span class="p">(</span><span class="n">current_idx</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">DataItem</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">current_idx</span> <span class="o">+</span> <span class="n">step</span>


<span class="n">size_increments</span><span class="p">:</span> <span class="n">IndexUpdater</span>


<span class="k">def</span> <span class="nf">size_increments</span><span class="p">(</span><span class="n">current_idx</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">DataItem</span><span class="p">,</span> <span class="n">size_func</span><span class="o">=</span><span class="nb">len</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">current_idx</span> <span class="o">+</span> <span class="n">size_func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<span class="n">current_time</span><span class="p">:</span> <span class="n">IndexUpdater</span>


<div class="viewcode-block" id="current_time"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.current_time">[docs]</a><span class="k">def</span> <span class="nf">current_time</span><span class="p">(</span><span class="n">current_idx</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Doesn&#39;t even look at current_idx or obj. Just gives the current time&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span></div>


<div class="viewcode-block" id="DynamicIndexer"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.DynamicIndexer">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">DynamicIndexer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param start: The index to start at (the first data item will have this index)</span>
<span class="sd">    :param idx_updater: The (Index, DataItem) -&gt; Index</span>

<span class="sd">    Let&#39;s take a finite stream of finite iterables (strings here):</span>

<span class="sd">    &gt;&gt;&gt; stream = [&#39;stream&#39;, &#39;of&#39;, &#39;different&#39;, &#39;sized&#39;, &#39;chunks&#39;]</span>

<span class="sd">    The default ``DynamicIndexer`` just does what ``enumerate`` does:</span>

<span class="sd">    &gt;&gt;&gt; counter_index = DynamicIndexer()</span>
<span class="sd">    &gt;&gt;&gt; list(map(counter_index, stream))</span>
<span class="sd">    [(0, &#39;stream&#39;), (1, &#39;of&#39;), (2, &#39;different&#39;), (3, &#39;sized&#39;), (4, &#39;chunks&#39;)]</span>

<span class="sd">    That&#39;s because it uses the default ``idx_updater`` function just increments by one.</span>
<span class="sd">    This function, DynamicIndexer.count_increments, is shown below</span>

<span class="sd">    &gt;&gt;&gt; def count_increments(current_idx, data_item, step=1):</span>
<span class="sd">    ...     return current_idx + step</span>

<span class="sd">    To get the index starting at 10, we can specify ``start=10``, and to step the</span>
<span class="sd">    index by 3 we can partialize ``count_increments``:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; step3 = partial(count_increments, step=3)</span>
<span class="sd">    &gt;&gt;&gt; list(map(DynamicIndexer(start=10, idx_updater=step3), stream))</span>
<span class="sd">    [(10, &#39;stream&#39;), (13, &#39;of&#39;), (16, &#39;different&#39;), (19, &#39;sized&#39;), (22, &#39;chunks&#39;)]</span>

<span class="sd">    You can specify any custom ``idx_updater`` you want: The requirements being that</span>
<span class="sd">    this function should take ``(current_idx, data_item)`` as the input, and</span>
<span class="sd">    return the next &quot;current index&quot;, that is, what the index of the next data item will</span>
<span class="sd">    be.</span>
<span class="sd">    Note that ``count_increments`` ignored the ``data_item`` completely, but sometimes</span>
<span class="sd">    you want to take the data item into account.</span>
<span class="sd">    For example, your data item may contain several elements, and you want your</span>
<span class="sd">    index to index these elements, therefore you should update your index by</span>
<span class="sd">    incrementing it with the number of elements.</span>

<span class="sd">    We have ``DynamicIndexer.size_increments`` for that, the code is shown below:</span>

<span class="sd">    &gt;&gt;&gt; def size_increments(current_idx, data_item, size_func=len):</span>
<span class="sd">    ...     return current_idx + size_func(data_item)</span>
<span class="sd">    &gt;&gt;&gt; size_index = DynamicIndexer(idx_updater=DynamicIndexer.size_increments)</span>
<span class="sd">    &gt;&gt;&gt; list(map(size_index, stream))</span>
<span class="sd">    [(0, &#39;stream&#39;), (6, &#39;of&#39;), (8, &#39;different&#39;), (17, &#39;sized&#39;), (22, &#39;chunks&#39;)]</span>

<span class="sd">    Q: What if I want the index of a data item to be a function of the data item itself?</span>

<span class="sd">    A: Then you would use that function to make the ``(idxof(data_item), data_item)``</span>
<span class="sd">    pairs directly. ``DynamicIndexer`` is for the use case where the index of an item</span>
<span class="sd">    depends on the (number of, sizes of, etc.) items that came before it.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start</span><span class="p">:</span> <span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idx_updater</span><span class="p">:</span> <span class="n">IndexUpdater</span> <span class="o">=</span> <span class="n">count_increments</span>

    <span class="n">count_increments</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">count_increments</span><span class="p">)</span>
    <span class="n">size_increments</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">size_increments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">_current_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_updater</span><span class="p">(</span><span class="n">_current_idx</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_current_idx</span><span class="p">,</span> <span class="n">x</span></div>


<div class="viewcode-block" id="dynamically_index"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.dynamically_index">[docs]</a><span class="k">def</span> <span class="nf">dynamically_index</span><span class="p">(</span><span class="n">iterable</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx_updater</span><span class="o">=</span><span class="n">count_increments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generalization of `enumerate(iterable)` that allows one to specify how the</span>
<span class="sd">    indices should be updated.</span>

<span class="sd">    The default is the sae behavior as `enumerate`: Starts with 0 and increments by 1.</span>

<span class="sd">    &gt;&gt;&gt; stream = [&#39;stream&#39;, &#39;of&#39;, &#39;different&#39;, &#39;sized&#39;, &#39;chunks&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert (list(dynamically_index(stream, start=2))</span>
<span class="sd">    ...     == list(enumerate(stream, start=2))</span>
<span class="sd">    ...     == [(2, &#39;stream&#39;), (3, &#39;of&#39;), (4, &#39;different&#39;), (5, &#39;sized&#39;), (6, &#39;chunks&#39;)]</span>
<span class="sd">    ... )</span>

<span class="sd">    Say we wanted to increment the indices according to the size of the last item</span>
<span class="sd">    instead of just incrementing by 1 at every iteration tick...</span>

<span class="sd">    &gt;&gt;&gt; def size_increments(current_idx, data_item, size_func=len):</span>
<span class="sd">    ...     return current_idx + size_func(data_item)</span>
<span class="sd">    &gt;&gt;&gt; size_index = DynamicIndexer(idx_updater=DynamicIndexer.size_increments)</span>
<span class="sd">    &gt;&gt;&gt; list(map(size_index, stream))</span>
<span class="sd">    [(0, &#39;stream&#39;), (6, &#39;of&#39;), (8, &#39;different&#39;), (17, &#39;sized&#39;), (22, &#39;chunks&#39;)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dynamic_indexer</span> <span class="o">=</span> <span class="n">DynamicIndexer</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">idx_updater</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">dynamic_indexer</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span></div>


<span class="c1"># Alternative to the above implementation:</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">accumulate</span>


<span class="k">def</span> <span class="nf">_dynamic_indexer</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">idx_updater</span><span class="p">:</span> <span class="n">IndexUpdater</span> <span class="o">=</span> <span class="n">count_increments</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">index_func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">accumulate</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">idx_updater</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="n">start</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index_func</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span> <span class="n">stream</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<div class="viewcode-block" id="alt_dynamically_index"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.alt_dynamically_index">[docs]</a><span class="k">def</span> <span class="nf">alt_dynamically_index</span><span class="p">(</span><span class="n">idx_updater</span><span class="p">:</span> <span class="n">IndexUpdater</span> <span class="o">=</span> <span class="n">count_increments</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alternative to dynamically_index using itertools and partial</span>

<span class="sd">    &gt;&gt;&gt; def size_increments(current_idx, data_item, size_func=len):</span>
<span class="sd">    ...     return current_idx + size_func(data_item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; stream = [&#39;stream&#39;, &#39;of&#39;, &#39;different&#39;, &#39;sized&#39;, &#39;chunks&#39;]</span>
<span class="sd">    &gt;&gt;&gt; indexer = alt_dynamically_index(size_increments)</span>
<span class="sd">    &gt;&gt;&gt; t = list(indexer(stream))</span>
<span class="sd">    &gt;&gt;&gt; assert t == [(0, &#39;stream&#39;), (6, &#39;of&#39;), (8, &#39;different&#39;), (17, &#39;sized&#39;),</span>
<span class="sd">    ...              (22, &#39;chunks&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_dynamic_indexer</span><span class="p">,</span> <span class="n">idx_updater</span><span class="o">=</span><span class="n">idx_updater</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">)</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Slicing index segment streams</span>


<div class="viewcode-block" id="segment_overlaps"><a class="viewcode-back" href="../../module_docs/creek/tools.html#creek.tools.segment_overlaps">[docs]</a><span class="k">def</span> <span class="nf">segment_overlaps</span><span class="p">(</span><span class="n">bt_tt_segment</span><span class="p">,</span> <span class="n">query_bt</span><span class="p">,</span> <span class="n">query_tt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if, and only if, bt_tt_segment overlaps query interval.</span>

<span class="sd">    A `bt_tt_segment` will need to be of the ``(bt, tt, *data)`` format.</span>
<span class="sd">    That is, an iterable of at least two elements (the ``bt`` and ``tt``) followed with</span>
<span class="sd">    more elements (the actual segment data).</span>

<span class="sd">    This function is made to be curried, as shown in the following example:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; overlapping_segments_filt = partial(segment_overlaps, query_bt=4, query_tt=8)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; list(filter(overlapping_segments_filt, [</span>
<span class="sd">    ...     (1, 3, &#39;completely before&#39;),</span>
<span class="sd">    ...     (2, 4, &#39;still completely before (upper bounds are strict)&#39;),</span>
<span class="sd">    ...     (3, 6, &#39;partially before, but overlaps bottom&#39;),</span>
<span class="sd">    ...     (4, 5, &#39;totally&#39;, &#39;inside&#39;),  # &lt;- note this tuple has 4 elements</span>
<span class="sd">    ...     (5, 8),  # &lt;- note this tuple has only the minimum (2) elements,</span>
<span class="sd">    ...     (7, 10, &#39;partially after, but overlaps top&#39;),</span>
<span class="sd">    ...     (8, 11, &#39;completely after (strict upper bound)&#39;),</span>
<span class="sd">    ...     (100, 101, &#39;completely after (obviously)&#39;)</span>
<span class="sd">    ... ]))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [(3, 6, &#39;partially before, but overlaps bottom&#39;),</span>
<span class="sd">    (4, 5, &#39;totally&#39;, &#39;inside&#39;),</span>
<span class="sd">    (5, 8),</span>
<span class="sd">    (7, 10, &#39;partially after, but overlaps top&#39;)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bt</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="o">*</span><span class="n">segment</span> <span class="o">=</span> <span class="n">bt_tt_segment</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">query_bt</span> <span class="o">&lt;</span> <span class="n">tt</span> <span class="o">&lt;=</span> <span class="n">query_tt</span>  <span class="c1"># the top part of segment intersects</span>
        <span class="ow">or</span> <span class="n">query_bt</span> <span class="o">&lt;=</span> <span class="n">bt</span> <span class="o">&lt;</span> <span class="n">query_tt</span>  <span class="c1"># the bottom part of the segment intersects</span>
        <span class="c1"># If it&#39;s both, the interval is entirely inside the query</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>